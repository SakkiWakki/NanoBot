# Env
from dotenv import load_dotenv
import os

# Web
import requests as py_requests
from flask import Flask, request as flask_request
from requests.auth import HTTPBasicAuth

# Crytography
import jwt
import base64
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import rsa

# Environment set-up
load_dotenv()
username = os.getenv("CLIENT_ID")
password = os.getenv("CLIENT_SECRET")
redirect_uri = os.getenv("REDIRECT_URI")
oidc_token_endpoint = os.getenv("OIDC_TOKEN_ENDPOINT")
jwk_source = os.getenv("JWK_SOURCE")
client_id = os.getenv("CLIENT_ID")
app = Flask(__name__)


@app.route("/auth")
def authorization_pipeline():
    """
    From Jun-Kun:
    user want to identify themselves, your bot send them to the mit authorize site with the corresponding parameters (not part of this function)
    the user login in that website, which will them redirect to your webserver with some information
    your server then send the information received to the token server
    the token server will use that information to verify and send a http response to your server with a json including the users token
    then you can verify the token

    Overall this code could be generalized for more cases, but the general cases will probably not be worked on unless
    someone requests them.
    """
    code = flask_request.args.get("code")
    state = flask_request.args.get("state")
    if not code or not state:
        # Set this to whatever default message you want for someone somehow randomly landing on the page
        return "This is a page you would need to defeat if you are an MIT-affiliate and wanted to join RG@MIT!"

    post_result = post_jws(code, state)

    if post_result.status_code == 200:
        return verify_token(post_result)

    return "An error has occurred! If retrying the verification doesn't work, contact yuckykaze on Discord for help!"


def post_jws(code, state):
    """
    Sends a post request hoping to receive a JWS as the result
    :param code: the authorization code generated by the OIDC server
    :param state: the random state value generated by the bot in the first step (auth.py)
    :return: the provided result of the post request. Will be a JWS if successful.
    """
    post_params = {
        "grant_type": "authorization_code",
        "code": code,
        "state": state,
        "redirect_uri": redirect_uri,
    }

    post_result = py_requests.post(
        url=oidc_token_endpoint,
        data=post_params,
        auth=HTTPBasicAuth(username, password),
    )

    return post_result


def verify_token(post_result):
    """
    This function will assume that we have a valid id_token from the post results. Will attempt to validate that
    token and check for any errors. If an error is found, then authentication process fails.

    TODO: perform additional checks on the decoded id-token values as specified
        iss: the issuer of the token, must be *https://oidc.mit.edu/*
        sub: machine-readable identifier of the user at this server; this value is guaranteed to be unique per user,
            stable over time, and never re-used
        exp: a timestamp of when the token expires, must not be in the past
        iat: a timestamp of when the token was issued, must not be in the future
        aud: a list of client_ids ("audience") the token is intended for; your client_id should be in this list.
        nonce: the nonce value sent during the token request
    """
    try:
        validate_token(post_result)
        return "Authentication success!"
    except jwt.ExpiredSignatureError:
        return "The signature has expired!"
    except jwt.InvalidTokenError:
        return "The provided token is invalid!"


def validate_token(post_result):
    """Verifies if the id_token is actually from the OIDC host (and not faked)"""
    jws = post_result.json()
    id_token = jws["id_token"]
    jwk = py_requests.get(jwk_source).json()["keys"][0]
    pem_key = create_pem_key(jwk)

    jwt.decode(
        id_token,
        pem_key,
        algorithms="RS256",
        audience=client_id
    )


def create_pem_key(jwk):
    """
    Converts a public key to the PEM format from the JWK format. Only required if the OIDC host only provides a key
    in the JWK format. Read up on RSA encryption here: https://en.wikipedia.org/wiki/RSA_(cryptosystem)
    """
    n_data = base64.urlsafe_b64decode(jwk["n"] + "==")
    e_data = base64.urlsafe_b64decode(jwk["e"] + "==")

    rsa_public_key = rsa.RSAPublicNumbers(
        e=int.from_bytes(e_data, "big"), n=int.from_bytes(n_data, "big")
    ).public_key(default_backend())

    pem_key = rsa_public_key.public_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PublicFormat.SubjectPublicKeyInfo,
    )

    return pem_key
